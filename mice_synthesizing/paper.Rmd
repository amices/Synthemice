---
title: "Outline paper - Multiple imputation for statistical disclosure control: Creating synthetic data sets with *mice*"
subtitle: "Anony*mice*d shareable data: Using *mice* to create multiply imputed synthetic data sets" 
author:
- Thom Volker & Gerko Vink
date: "`r format(Sys.time(), '%d-%m-%Y')`"
output: 
  html_document:
    theme: spacelab
    highlight: tango
    toc: true
    toc_depth: 2
    toc_float: true
    number_sections: true
bibliography: federated_imp.bib
csl: "apa-6th-edition.csl"
---

# OUTLINE

## Introduction

- [x] What is synthetic data?
- [x] Why is it useful?
- [x] Why should it be easy to generate?
- [x] Parallel to missing data
- [x] If similar to missing data, then why not use `mice`?
- [x] `mice` can only be exploited if the statistical properties are correct.
- [x] In this paper we demonstrate a straightforward workflow for generating synthetic data sets and we investigate how to obtain valid inferences from synthesized data.

## Generating synthetic data with `mice`

- [x] Explain FCS in short.
- [x] Demonstrate procedure with `where-matrix` and explain rationale.
- [ ] Demonstrate that this is a reasonable approach, based on a figure that shows the observed and synthetic relationships side-by-side (e.g. `wgt ~ age + gen`).
- [ ] Observed values can be regarded as starting values for the imputation model. Since the observed data is used for creating the imputation models, no iterations are required. That is, the model is fixed, and not dependent on the imputed values.

## Drawing inferences from `mice` synthesized data

- [ ] What ways are there (with minimal - if any - escapes to partially/fully synthetic data).
- [ ] If based on your earlier work, cite the online reference for your simulations and give URL. No need to go into detail about it here.

### Simulation

- [ ] Simulation set-up.
- [ ] Evaluation criteria explained: the bias, coverage and CIW triangle.
- [ ] Table which demonstrates bias, coverage and CIW for all methods.

## Discussion

- [ ] Summarize findings.
- [ ] Stress that only holds for sampled data. Explain that for fully observed populations, one would need no sampling variance.
- [ ] Revisit the simplicity and the readily available solution within the `mice` workflow (if adjusted pool is required, add to mice and direct to that function).


# Introduction

<!-- 
WHY WE NEED SYNTHETIC DATA - PARAGRAPHS FROM Lazer, D., Pentland, A. S., Adamic, L., Aral, S., Barabasi, A. L., Brewer, D., Gutmann, M. (2009). Life in the network: The coming age of computational social science. Science, 323(5915), 721. http://doi.org/10.1111/j.1083-6101.2007.00367.x 


There are also enormous institutional obsta-cles to advancing a computational social sci-ence.  In  terms  of  approach,  the  subjects  ofinquiry in physics and biology present differentchallenges  to  observation  and  intervention.Quarks and cells neither mind when we dis-cover their secrets nor protest if we alter theirenvironments during the discovery process. Asfor infrastructure, the leap from social scienceto a computational social science is larger thanfrom  biology  to  a  computational  biology,largely due to the requirements of distributedmonitoring, permission seeking, and encryp-tion. There are fewer resources available in thesocial  sciences,  and  even  the  physical  (andadministrative) distance between social sciencedepartments and engineering or computer sci-ence departments tends to be greater than forthe other sciences. Perhaps the thorniest challenges exist on thedata side, with respect to access and privacy.Much of these data are proprietary (e.g., mobilephone and financial transactional information).The debacle following AOL’s public release of“anonymized” search records of many of itscustomers highlights the potential risk to indi-viduals and corporations in the sharing of per-sonal data by private companies (14). Robustmodels  of  collaboration  and  data  sharingbetween industry and academia are needed tofacilitate research and safeguard consumer pri-vacy and provide liability protection for corpo-rations. More generally, properly managing pri-vacy  issues  is  essential.  As  the  recent  U.S.National  Research  Council’s  report  on  geo-graphical information system data highlights, itis often possible to pull individual profiles outof even carefully anonymized data (15). Lastyear, the U.S. National Institutes of Health andthe Wellcome Trust abruptly removed a num-ber of genetic databases from online access(16). These databases were seemingly anony-mized,  simply  reporting  the  aggregate  fre-quency of particular genetic markers. How-ever, research revealed the potential for de-anonymization, based on the statistical powerof the sheer quantity of data collected fromeach individual in the database (17).Because a single dramatic incident involv-ing a breach of privacy could produce rulesand statutes that stifle the nascent field of com-putational  social  science,  a  self-regulatoryregime of procedures, technologies, and rulesis needed that reduces this risk but preservesresearch potential. As a cornerstone of such aself-regulatory regime, U.S. Institutional Re-view Boards (IRBs) must increase their techni-cal knowledge to understand the potential forintrusion and individual harm because newpossibilities do not fit their current paradigmsfor harm. Many IRBs would be poorly equip-ped to evaluate the possibility that complexdata could be de-anonymized. Further, it maybe necessary for IRBs to oversee the creationof  a  secure,  centralized  data  infrastructure.Currently,  existing  data  sets  are  scatteredamong many groups, with uneven skills andunderstanding  of  data  security  and  widelyvarying  protocols.  Researchers  themselvesmust develop technologies that protect privacywhile preserving data essential for research.These systems, in turn, may prove useful forindustry in managing customer privacy anddata security (18). -->


Open science, including open data, has been marked as the future of science [@gewin_data_2016], and the advantages of publicly available research data are numerous [@molloy_open_2011; @walport_brest_sharing_2011]. Collecting research data requires an enormous investment both in terms of time and monetary resources. Openly accessible research data bears the potential of increasing the scientific returns for the same data collection effort. Additionally, the fact that public funds are used for data collection results in increasing demand for the collected data. Nevertheless, the possibilities to distribute research data directly are often very limited due to restrictions on data privacy and data confidentiality. Although these regulations are much needed, privacy constraints are also ranked among the toughest challenges to overcome in the advancement of modern day social science research [@lazer_life_2009].

Anonymizing research data might seem a quick and appealing approach to limit the unique identification of participants. However, this approach is not sufficient to fulfil contemporary privacy and confidentiality requirements [@ohm_broken_2009; @national_putting_2007]. Over the years, several other techniques have been used to increase the confidentiality of research data, such as categorizing continuous variables, top coding values above an upper bound or adding random noise to the observed values [@drechsler_synthetic_2011]. However, these methods may distort the true data relation between variables, thereby reducing the data quality and the scientific returns for re-using the same data for further research. 

An alternative solution has been proposed separately by @rubin_statistical_disclosure_1993 and @little_statistical_1993. Although their approaches differ to some extent, the overarching procedure is to use bonafide observed data to generate multiply imputed synthetic data sets that can be freely disclosed. While in practice, one could see this as replacing the observed data values by multiple draws from the posterior predictive distribution of the observed data, based on some imputation model, Rubin would argue that these synthetic data values are merely draws from the same true data generating model. In that sense, the observed data is never replaced, but the population is resampled from the information captured in the (incomplete) sample. Using this approach, the researcher could replace the observed data set as a whole with multiple synthetic versions. Alternatively, the researcher could opt to only replace a subset of the observed data. For example, one can choose to only replace dimensions in the data that could be compared with publicly available data sets or registers. Likewise, synthetisation could be limited to those values that are disclosive, such as high incomes or high turnovers. <!-- I don't think so, because the synthetic values can only be linked to observed values from other sources if they are exactly equal, or if they are the only value within a certain range. The latter might be possible when the number of values is very small, or when the observed value is so extreme that synthetic versions will still be so extreme. However, if the other values are synthetic as well, it is quite likely that synthetic information does not apply to the real-world observation. I think that the highest risk is in the possibility to extract a range of possible values, which might be uniquely match some other record that is available. -->

Conceptually, the synthetic data framework is based upon the building blocks of multiple imputation of missing data, as proposed by @rubin_multiple_1987. Instead of replacing just the missing values with multiple draws from the posterior predictive distribution, one could easily *overimpute* any observed sensitive values. Similarly to multiple imputation of missing data, the multiple synthetic data sets allow for correct statistical inferences, **regardless of the fact that the analyses do not use the "true" value**. The analyses over multiple synthetic data sets should be pooled into a single inference, so that the researcher can draw valid conclusions from the pooled results. To that respect, the variance should reflect the added variability that is induced by the imputation procedure. 

Potentially, this approach could fulfill the needs for openly accessibly data, without running into barriers with regard to privacy and confidentiality constraints. However, there is no such thing as a free lunch: data collectors have to put effort in creating high-quality synthetic data. Also, the quality of the synthetic data is highly dependent on the imputation models, and using flawed models to generate synthetic data might bias subsequent analyses. Conversely, if the models used to create the synthetic data are able to preserve the relationships between the variables as in the original data, the synthetic data can be nearly as informative as the observed data. Thus, to fully exploit the benefits of synthetic data, the effort to actually create these high-quality data sets should be kept at a minimum.

To mitigate additional effort of creating synthetic data sets on behalf of the researcher, software aimed at multiple imputation of missing data can be employed. Especially if researchers used this software at an earlier stage in the research process, or acquired familiarity with it during earlier projects, the additional burden of creating synthetic data sets is relatively small. The R-package `mice` [@mice] implements multiple imputation of missing data in a straightforward and user-friendly manner. However, the functionality of `mice` is not restricted to the imputation of missing data, but allows to impute any value in the data: even observed values. Consequently, `mice` can be utilized for the creation of multiply imputed synthetic data sets. 

After creating the multiply imputed synthetic data sets, the goal is to obtain valid statistical inferences in the spirit of @rubin_multiple_1987 and @neyman1934. In the missing data framework, this is done by performing statistical analyses on all imputed data sets, and pooling the results of the analyses according to Rubin's rules [@rubin_multiple_1987, pp.76]. In the synthetic data framework, the same procedure is followed, but with a slight twist: there are no values that remain constant over the synthetic data sets. The procedure of drawing valid inferences from multiple synthetic data sets is therefore slightly different. 

In this manuscript we detail a workflow for synthesizing data with `mice`. First, the `mice` algorithm for the creation of synthetic data will be shortly explained. The aim is to generate synthetic sets that reassure the privacy and confidentiality of the participants. Second, a straightforward workflow for imputation of synthetic data with `mice` will be demonstrated. Third, we demonstrate the validity of the procedure through statistical simulation.  

# Generating synthetic data with `mice`

**NEXT TWO PARAGRAPHS ARE PROBABLY NOT CORRECT YET; NOTE TO SELF: UPDATE THIS**

The `mice` package [@mice] in `R` [@Rproject] has been developed for multiple imputation of missing data. In this context, the aim is to replace missing values due to nonresponse by plausible values from the posterior predictive distribution of the variable containing the missings. Doing so, `mice` makes use of fully conditional specification [FCS; @vanbuuren_fully_2006], which breaks down the multivariate distribution of the data $\textbf{Y} = (\textbf{Y}_{obs}, \textbf{Y}_{mis})$ into $j = 1, 2, \dots, k$ univariate conditional densities, where $k$ denotes the number of columns in the data. Using FCS, a model is constructed for every incomplete variable and the missing values $Y_{j, mis}$ are then imputed with draws from the posterior predictive distribution of $P(Y_{j, mis} | \textbf{Y}_{obs}, \theta)$ on a variable-by-variable basis. Note that the predictor matrix $Y_{-j}$ may contain yet imputed values from an earlier imputation step, and thus will be updated after every iteration. This procedure is applied $m$ times, resulting in $m$ completed data sets $\textbf{D} = (\textbf{D}^{(1)}, \textbf{D}^{(2)}, \dots, \textbf{D}^{(m)})$, with $\textbf{D}^{(l)} = (\textbf{Y}_{obs}, Y^{(l)}_{mis})$.

In `mice`, the generation of multiply imputed data sets to solve for unobserved values is straightforward. The following pseudocode details the multiple imputation of the `mice::boys` data set [@fredriks_boys_2000] into the object `imp` with `m = 10` imputated sets and `maxit = 7` iterations for the algorithm to converge, using the default imputations methods for each column data class.

```{r eval = FALSE}
library(mice)
imp <- mice(boys, 
            m = 10,
            maxit = 7)
```

It is straightforward to extended the imputation approach to generate synthetic values. Rather than imputing missing data, the observed values are then replaced by synthetic draws from the posterior predictive distribution. For simplicity, assume that the data is completely observed (i.e., $\textbf{Y} = \textbf{Y}_{obs}$). Following the notation of @reiter_raghunathan_multiple_2007, let for $n$ units denote $Z_i = 1$ if any of the values of unit $i = 1, 2, \dots, n$ are to be replaced by imputations, and $Z_i = 0$ otherwise, with $\textbf{Z} = (Z_1, Z_2, \dots, Z_n)$. Accordingly, the data consists of values that are to be replaced and values that are to be kept (i.e., $\textbf{Y} = (\textbf{Y}_{rep}, \textbf{Y}_{nrep})$. Now, instead of imputing $\textbf{Y}_{mis}$ with draws from the posterior predictive distribution of $P(Y_{j, mis} | \textbf{Y}_{obs}, \theta)$ as in the missing data case, $\textbf{Y}_{rep}$ is imputed from the posterior distribution of $P(Y^{(l)}_{j, rep} | \textbf{Y}^{(l)}_{-j}, \textbf{Z}, \theta)$, where $l$ is an indicator for the synthetic data set ($l = 1, 2, \dots, m$). Note that synthetic values that are imputed at an earlier step can be used for imputing variable $j$. This process results in the synthetic data $\textbf{D} = (\textbf{D}^{(1)}, \textbf{D}^{(2)}, \dots, \textbf{D}^{(m)})$. 

For example, overimputing synthetic values for both the observed and missing cells in the `mice::boys` data set into the object `syn`, given the same imputation parameters as before, can be realized by the following code execution.

```{r eval = FALSE}
syn <- mice(boys, 
            m = 10,
            maxit = 7, 
            where = matrix(TRUE, 
                           nrow = nrow(boys),
                           ncol = ncol(boys)))
```

where the argument `where` requires a matrix of the same dimensions as the data, (i.e., a $n \times k$ matrix) containing logicals $z_{ij}$ that indicate which cells are selected to have their values replaced by draws from the posterior predictive distribution. This approach allows to *overimpute* a subset of the observed data, or - as in the above example - the observed data as a whole, resulting in a data set that partly or completely consists of synthetic data values. 

Choosing an adequate imputation model to impute the data is paramount, as a flawed imputation model may drastically impact the validity of inferences. Imputation models should be as flexible as possible to capture most of the patterns in the data, and to model possibly unanticipated data characteristics [@murray_multiple_2018; @rubin_18years_1996]. Parametric methods, albeit easy to implement in practice, may be too restrictive to capture generally complex patterns in the data, especially in the case of nonlinear relations and interactions between multiple variables. Classification and regression trees [CART; @breiman_cart_1984] allow to model more complex patterns in the data, and have therefore been suggested as an appropriate imputation method [@reiter_cart_2005; @burgette_reiter_cart_2010; @doove_buuren_recursive_2014]. Loosely speaking, CART sequentially splits the predictor space into non-overlapping regions in such a way that the within-region variance is as small as possible after every split. As such, CART does not impose any parametric distribution on the data, making it a widely applicable method that allows for a large variety of relationships within the data [@islr_2013]. Given these appealing characteristics and the call for the use of flexible methods when multiply imputing data, we will focus our illustrations and evaluations of `mice` to method `mice.impute.cart()`, realized by:

```{r eval = FALSE}
syn <- mice(boys, 
            m = 10,
            maxit = 7, 
            method = "cart",
            where = matrix(TRUE, 
                           nrow = nrow(boys),
                           ncol = ncol(boys)))
```


In a nutshell, the above code shows the simplicity of creating $m = 10$ synthetic data sets using `mice`. In practice, however, one should take some additional complicating factors into account. For example, one should account for deterministic relations in the data. Additionally, relations between variables may be described best using a different model than `CART`. Such factors are data dependent and should be considered by the imputer. In the next section, we will describe how the `boys` data can be adequately imputed. Additionally, we will show through simulations that this approach yields valid inferences.

# Simulations

We demonstrate the suitability of using `mice` for synthesization using a simulation study on the `mice::boys` data set. This data set consists of the values of $`r nrow(mice::boys)`$ Dutch boys on the following $`r ncol(mice::boys)`$ variables: 

| column | description                |
|--------|----------------------------|
| age    | age in years               |
| hgt    | height (cm)                |
| wgt    | weight (kg)                |
| bmi    | body mass index            |
| hc     | head circumference (cm)    |
| gen    | genital Tanner stage G1-G5 |
| phb    | pubic hair Tanner P1-P6    |
| tv     | testicular volume (ml)     |
| reg    | region                     |

Unfortunately, this data set does not differ from the vast majority of collected data sets, in the sense that it suffers from missing data. For simplicity, the data is completed using the default `mice` imputation model for all predictors except `bmi`, which is passively imputed using its deterministic relation with weight and height.

```{r, include = FALSE}
library(mice)
library(tibble)
library(magrittr)
library(tidyverse)
library(furrr)
library(knitr)
library(kableExtra)
library(psych)
library(purrr)
library(dplyr)
library(knitr)
library(kableExtra)
```


```{r, results = FALSE, message = FALSE, warning = FALSE}
# create a single imputed, completely observed `boys` data set
set.seed(123)

meth <- make.method(boys)
meth["bmi"] <- "~ I(wgt / (hgt / 100)^2)"
pred <- make.predictorMatrix(boys)
pred[c("hgt", "wgt"), "bmi"] <- 0

imp <- mice(boys, 
            m = 1,
            maxit = 10,
            method = meth,
            predictorMatrix = pred)

data <- complete(imp)
```

## Simulation methods

To induce sampling variance, 1000 bootstrap samples of the `boys` data will be synthesized with $m = 5$ imputations. Synthetic values are generated using the `CART` imputation method for all columns, except for `bmi`. The deterministic relation `bmi` which will be synthesized passively based on the synthetic values for `hgt` and `wgt` to preserve the relation in the synthetic data. Additional parameters that come with the use of `mice.impute.cart()` are the complexity parameter `cp` and the minimum number of observations in any terminal node `minbucket`, that both constrain the flexibility of the imputation model. The values of the parameters `cp` and `minbucket` ought to adhere to the call for imputation models that are as flexible as possible. Appropriate values for these parameters, as well as the input for the `predictorMatrix`, depend on the data at hand. In the current example, the complexity parameter is specified at `cp = 1e-08` rather than the default value `1e-04`, and the minimum number of observations in each terminal node is set at `minbucket` $= 3$ rather than the default value $5$. By allowing for more complexity in the imputation model, bias in the estimates from the synthetic data set is reduced. Additionally, since the missingness pattern is monotone, the number of iterations can be set to `maxit = 1`.

To assess the performance of `mice` for synthesizing data, we compare the bootstrapped samples with the synthetic versions of these bootstrapped samples. Specifically, univariate descriptive statistics, the correlation matrix, and two linear regression models as well as one ordered logistic regression model will be considered. Subsequently, the bias in the parameters and the $95\%$ confidence interval coverage of the synthetic data will be examined. Similarly to multiple imputation of missing data, correct inferences from synthetic data requires correct pooling over the multiply imputed data sets. 

Obtaining a final point estimate of the parameter of interest $Q$ after imputation is fairly easy and no different from pooling in the case of missing data [@rubin_multiple_1987]. One can calculate the average of the $m$ point estimates $q^{(l)}$
$$
\bar{q}_m = \sum_{l = 1}^m \frac{q^{(l)}}{m}.
$$
with $l = 1, \dots, m$. 

Similarly to the missing data case, variances, and subsequently confidence intervals, should incorporate the increase in variance that is due to imputation [@reiter_partially_inference_2003; @drechsler_synthetic_2011]. Yet, the increase in variance due to imputation differs according to whether missing values are imputed or observed data is overimputed with missing values. Whereas the variance estimate after imputation of missing data needs to account for the fact that a certain amount of information in the data is missing, variance estimation from synthetic data does not suffer from this issue. The adjusted variance estimate that follows from using multiple synthetic data sets only suffers from the fact that a finite number of $m$ synthetic data sets are used to resemble the observed data. Hence, the according variance estimate for synthetic data as developed by @reiter_partially_inference_2003 yields
$$
T = \bar{u}_m + \frac{b_m}{m},
$$
with between variance

$$
b_m = \sum_{l = 1}^m \frac{(q^{(l)} - \bar{q}_m)^2}{(m - 1)}, \\
$$
and sampling variance
$$
\bar{u}_m = \sum_{l = 1} \frac{u^{(l)}}{m},
$$
with $u^{(l)}$ reflecting the variance estimate in the $l$th synthetic data set.

# Simulation results
```{r, message = FALSE, warning = FALSE, cache = TRUE, cache.lazy = FALSE}
plan(multisession) # increase speed through futures

true_model_age <- lm(age ~ wgt + hgt, data) # model 1
true_model_wgt <- lm(wgt ~ age + hgt, data) # model 2
true_model_gen <- MASS::polr(gen ~ age + hc + reg, data, Hess = TRUE) # model 3

coefs_age <- broom::tidy(true_model_age)$estimate # extract coefficients of model 1
coefs_wgt <- broom::tidy(true_model_wgt)$estimate # extract coefficients of model 2
coefs_gen <- broom::tidy(true_model_gen)$estimate # extract coefficients of model 3

nsim <- 1000 # use 1000 iterations

bootstrap_samples <- 
  modelr::bootstrap(data = data, n = nsim) %$% 
  strap %>% 
  map(as_tibble)

post <- make.post(data)
post["bmi"] <- "imp[[j]][, i] <- imp[['wgt']][, i] / (imp[['hgt']][, i] / 100)^2"

synthetic_samples <- 
  bootstrap_samples %>%
  future_map(function(x) {
    x %>% mice(m = 5, 
               maxit = 1,
               method = "cart",
               minbucket = 3,
               cp = 1e-08,
               predictorMatrix = pred,
               post = post,
               where = matrix(TRUE, nrow(data), ncol(data)),
               print = F)
}, .options = furrr_options(seed = as.integer(123)))

true_age <- 
  bootstrap_samples %>%
  map_dfr(~lm(age ~ wgt + hgt, .x) %>%
            broom::tidy(conf.int = TRUE))

true_wgt <-
  bootstrap_samples %>%
  map_dfr(~lm(wgt ~ age + hgt, .x) %>% 
            broom::tidy(conf.int = TRUE))

true_gen <- 
  bootstrap_samples %>%
  map_dfr(~MASS::polr(gen ~ age + hc + reg, .x, Hess = TRUE) %>%
            broom::tidy(conf.int = TRUE))

synthetic_age <- 
  synthetic_samples %>%
  map_dfr(function(x) {
    x %$% 
      lm(age ~ wgt + hgt) %>%
      mice:::pool.syn() %>%
      summary(conf.int = TRUE)
    })

synthetic_wgt <- 
  synthetic_samples %>%
  map_dfr(function(x) {
    x %$%
      lm(wgt ~ age + hgt) %>%
      mice:::pool.syn() %>%
      summary(conf.int = TRUE)
  })

synthetic_gen <- 
  synthetic_samples %>%
  map_dfr(function(x) {
    x %$%
      MASS::polr(gen ~ age + hc + reg, Hess = TRUE) %>%
      mice:::pool.syn() %>%
      summary(conf.int = TRUE)
  })
```

```{r}
true_age %>%
  mutate(truth = rep(coefs_age, nrow(.) / length(coefs_age)),
         covered = conf.low < truth & truth < conf.high) %>%
  group_by(term) %>%
  summarize(estimate = mean(estimate),
            bias = mean(estimate - truth),
            var = mean(std.error^2),
            lower = mean(conf.low),
            upper = mean(conf.high),
            coverage = mean(covered), .groups = "drop") %>%
  kable(digits = 3,
        caption = "Bootstrapped regression estimates (1000 times) for age 
        regressed on weight and height.") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))

synthetic_age %>%
  mutate(truth = rep(coefs_age, nrow(.) / length(coefs_age)),
         covered = `2.5 %` < truth & truth < `97.5 %`) %>%
  group_by(term) %>%
  summarize(estimate = mean(estimate),
            bias = mean(estimate - truth),
            var = mean(std.error^2),
            lower = mean(`2.5 %`),
            upper = mean(`97.5 %`),
            coverage = mean(covered), .groups = "drop") %>%
  kable(digits = 3,
        caption = "Synthetic regression estimates after bootstrapping (1000 
        times) and synthesizing for age regressed on weight and height.") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))

true_wgt %>%
  mutate(truth = rep(coefs_wgt, nrow(.) / length(coefs_wgt)),
         covered = conf.low < truth & truth < conf.high) %>%
  group_by(term) %>%
  summarize(estimate = mean(estimate),
            bias = mean(estimate - truth),
            var = mean(std.error^2),
            lower = mean(conf.low),
            upper = mean(conf.high),
            coverage = mean(covered), .groups = "drop") %>%
  kable(digits = 3,
        caption = "Bootstrapped regression estimates (1000 times) for weight 
        regressed on age and height.") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))

synthetic_wgt %>%
  mutate(truth = rep(coefs_wgt, nrow(.) / length(coefs_wgt)),
         covered = `2.5 %` < truth & truth < `97.5 %`) %>%
  group_by(term) %>%
  summarize(estimate = mean(estimate),
            bias = mean(estimate - truth),
            var = mean(std.error^2),
            lower = mean(`2.5 %`),
            upper = mean(`97.5 %`),
            coverage = mean(covered), .groups = "drop") %>%
  kable(digits = 3,
        caption = "Synthetic regression estimates after bootstrapping (1000 
        times) and synthesizing for weight regressed on age and height.") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))

true_gen %>%
  mutate(truth = rep(coefs_gen, nrow(.) / length(coefs_gen)),
         covered = conf.low < truth & truth < conf.high) %>%
  group_by(term) %>%
  summarize(estimate = mean(estimate),
            bias = mean(estimate - truth),
            var = mean(std.error^2),
            lower = mean(conf.low),
            upper = mean(conf.high),
            coverage = mean(covered), .groups = "drop") %>%
  kable(digits = 3,
        caption = "Bootstrapped regression estimates (1000 times) for 
        genital Tanner stage regressed on age, head circumference and 
        region. ") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))

synthetic_gen %>%
  mutate(truth = rep(coefs_gen, nrow(.) / length(coefs_gen)),
         covered = `2.5 %` < truth & truth < `97.5 %`) %>%
  group_by(term) %>%
  summarize(estimate = mean(estimate),
            bias = mean(estimate - truth),
            var = mean(std.error^2),
            lower = mean(`2.5 %`),
            upper = mean(`97.5 %`),
            coverage = mean(covered), .groups = "drop") %>%
  kable(digits = 3,
        caption = "Synthetic regression estimates after bootstrapping (1000
        times) and synthesizing for genital Tanner stage regressed on age,
        head circumference and region.") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
```

## Univariate estimates
The univariate descriptives for the original data and the synthetic data can be found in the folowing table. [TABLE REF]
```{r}
true <- psych::describe(data)

synth <- synthetic_samples %>% 
  map(~.x %>% complete("all") %>% 
        map(~.x %>% describe()) %>% Reduce("+", .) / synthetic_samples[[1]]$m) %>% 
  Reduce("+", .) / length(synthetic_samples)
rownames(true) <- paste("original", rownames(true), sep = " ")
rownames(synth) <- paste("synthetic", rownames(synth), sep = " ")

bind_rows(true, setNames(synth, names(true))) %>% 
           arrange(vars) %>% .[, c(2:5, 8:9, 11:12)] %>% round(3)
```

$$
% latex table generated in R 4.1.0 by xtable 1.8-4 package
% Sun Oct  3 23:20:37 2021
\begin{table}[ht]
\centering
\begin{tabular}{rrrrrrrrr}
  \hline
 & n & mean & sd & median & min & max & skew & kurtosis \\ 
  \hline
age & 748.00 & 9.16 & 6.89 & 10.50 & 0.04 & 21.18 & -0.03 & -1.56 \\ 
  age\_synth & 748.00 & 9.23 & 6.91 & 10.51 & 0.04 & 20.93 & -0.05 & -1.56 \\ 
  hgt & 748.00 & 131.10 & 46.52 & 145.75 & 50.00 & 198.00 & -0.30 & -1.47 \\ 
  hgt\_synth & 748.00 & 131.59 & 46.72 & 146.09 & 50.71 & 197.47 & -0.30 & -1.47 \\ 
  wgt & 748.00 & 37.12 & 26.03 & 34.55 & 3.14 & 117.40 & 0.38 & -1.03 \\ 
  wgt\_synth & 748.00 & 37.44 & 26.23 & 34.87 & 3.36 & 113.04 & 0.36 & -1.05 \\ 
  bmi & 748.00 & 18.04 & 3.04 & 17.45 & 11.73 & 31.74 & 1.14 & 1.79 \\ 
  bmi\_synth & 748.00 & 18.04 & 3.10 & 17.44 & 11.41 & 32.09 & 1.09 & 1.70 \\ 
  hc & 748.00 & 51.62 & 5.86 & 53.10 & 33.70 & 65.00 & -0.91 & 0.12 \\ 
  hc\_synth & 748.00 & 51.65 & 5.88 & 53.19 & 34.30 & 62.12 & -0.93 & 0.16 \\ 
  gen* & 748.00 & 2.53 & 1.59 & 2.00 & 1.00 & 5.00 & 0.52 & -1.36 \\ 
  gen*\_synth & 748.00 & 2.58 & 1.59 & 2.00 & 1.00 & 5.00 & 0.47 & -1.40 \\ 
  phb* & 748.00 & 2.75 & 1.86 & 2.00 & 1.00 & 6.00 & 0.56 & -1.25 \\ 
  phb*\_synth & 748.00 & 2.80 & 1.88 & 2.00 & 1.00 & 6.00 & 0.52 & -1.30 \\ 
  tv & 748.00 & 8.43 & 8.12 & 3.00 & 1.00 & 25.00 & 0.85 & -0.78 \\ 
  tv\_synth & 748.00 & 8.65 & 8.23 & 3.39 & 1.00 & 25.00 & 0.80 & -0.88 \\ 
  reg* & 748.00 & 3.02 & 1.14 & 3.00 & 1.00 & 5.00 & -0.08 & -0.77 \\ 
  reg*\_synth & 748.00 & 3.03 & 1.13 & 3.00 & 1.00 & 5.00 & -0.07 & -0.73 \\ 
   \hline
\end{tabular}
\end{table}
$$

We see that the synthetic data estimates resemble the true data estimates very well. 


# Variable plots

```{r}
## Merely illustrative, single data set, plot of age
synthetic_samples[[1]] %>% 
  complete(action = "long", include = TRUE) %>%
  mutate(Synthetic = ifelse(.imp == 0, "Real data", "Synthetic data")) %>%
  ggplot(mapping = aes(x = age, y = ..density.., fill = Synthetic)) +
  geom_histogram(position = "dodge") +
  scale_fill_brewer(palette = "Paired") +
  theme_classic()

## Merely illustrative, single data set, plot of gen

synthetic_samples[[2]] %>%
  complete(action = "long", include = TRUE) %>% 
  mutate(Synthetic = ifelse(.imp == 0, "Real data", "Synthetic data")) %>%
  ggplot(mapping = aes(x = gen, fill = Synthetic, group = Synthetic)) +
  geom_bar(aes(y = ..prop..), position = "dodge2") +
  scale_fill_brewer(palette = "Paired") +
  theme_classic()

## Merely illustrative, single data set, plot of bmi by region
synthetic_samples[[3]] %>%
  complete(action = "long", include = TRUE) %>%
  mutate(Synthetic = ifelse(.imp == 0, "Real data", "Synthetic data")) %>%
  ggplot(mapping = aes(x = reg, y = bmi, fill = Synthetic)) +
  geom_boxplot() +
  scale_fill_brewer(palette = "Paired") +
  theme_classic()
```


# Parameter plots

```{r}
# Univariate -- sampling distribution of the mean of age
synthetic_samples %>%
  map_dfr(function(x) {
    x %>%
      complete(action = "long", include = TRUE) %>%
      mutate(Synthetic = ifelse(.imp == 0, "Real data", "Synthetic data")) %>%
      group_by(Synthetic) %>%
      dplyr::summarize(`Mean age` = mean(age))
}) %>%
  ggplot(mapping = aes(x = `Mean age`, y = ..density.., fill = Synthetic)) +
  geom_histogram(position = "dodge") +
  scale_fill_brewer(palette = "Paired") +
  theme_classic()

# Univariate -- sampling distribution of the proportion of cases in 
# every gen category
synthetic_samples %>%
  map_dfr(function(x) {
    x %>%
      complete(action = "long", include = TRUE) %>% 
      mutate(Synthetic = ifelse(.imp == 0, "Real data", "Synthetic data")) %>%
      group_by(Synthetic, gen) %>%
      dplyr::summarize(number = n(), .groups = "drop") %>%
      group_by(Synthetic) %>%
      mutate(prop = number / sum(number))
  }) %>%
  ggplot(aes(x = gen, y = prop, fill = Synthetic)) +
  geom_boxplot() +
  scale_fill_brewer(palette = "Paired") +
  theme_classic()

bind_rows(`Real data`      = select(true_age, 
                                    Variable = term, 
                                    Estimate = estimate),
          `Synthetic data` = select(synthetic_age, 
                                    Variable = term, 
                                    Estimate = estimate),
          .id = "Synthetic") %>%
  ggplot(aes(x = Estimate, fill = Synthetic)) +
  geom_density(alpha = 0.8) +
  scale_fill_brewer(palette = "Set1") +
  theme_classic() +
  facet_wrap(~Variable, scales = "free")

bind_rows(`Real data`      = select(true_wgt, 
                                    Variable = term, 
                                    Estimate = estimate),
          `Synthetic data` = select(synthetic_wgt, 
                                    Variable = term, 
                                    Estimate = estimate),
          .id = "Synthetic") %>%
  ggplot(aes(x = Estimate, fill = Synthetic)) +
  geom_density(alpha = 0.8) +
  scale_fill_brewer(palette = "Set1") +
  theme_classic() +
  facet_wrap(~Variable, scales = "free")

bind_rows(`Real data`      = select(true_gen,
                                    Variable = term, 
                                    Estimate = estimate),
          `Synthetic data` = select(synthetic_gen,
                                    Variable = term,
                                    Estimate = estimate),
          .id = "Synthetic") %>%
  ggplot(aes(x = Estimate, fill = Synthetic)) +
  geom_density(alpha = 0.8) +
  scale_fill_brewer(palette = "Set1") +
  theme_classic() +
  facet_wrap(~Variable, nrow = 4, scales = "free") +
  theme(legend.position = "right")
```


```{r eval = FALSE}
syn <- mice(boys,
            m = 10,
            maxit = 7,
            method = "cart",
            where = matrix(TRUE,
                           nrow = nrow(boys),
                           ncol = ncol(boys)),
            cp = 1e-08,
            minbucket = 3)
```


# Simulation setup
- boys data met bootstrap om sampling variance er in te brengen
- wat evalueren we: bias | standard error | coverage
- welke pooling: T = Ubar + B/m
# psych::describe
# correlation matrix
# wgt ~ age + bmi | hgt ~ age + wgt | gen ~ age + 
# psych::describe - univariate ok
map --> psych::describe() --> Reduce("+", .) in de pipe

# correlation matrix - relations preserved
map --> cor --> logit --> pool --> inv.logit --> correct diagonal

# wgt ~ age + bmi | hgt ~ age + wgt | gen ~ age + bmi - multivariate ok
3 sets modellen

complete(imp, "all") 
--> lm1
--> lm2
--> polr

pooling cf. T = Ubar + B/m

# Conclusie
- We hebben laten zien dat het belangrijk is om meerdere synthetische versies te creeren. Dit is ook geen probleem, dat doen we immers al decennia lang met imputeren. 
- Waarom geen synthpop --> Ibrahim 2000
- werkt wel goed.
- Beperkingen
- Wat verder nog te doen: aanvullende functies voor complexere combinaties van synthetiseren en imputeren

We demonstrated that generating synthetic data sets with `mice` in `R` is a straightforward process that fits well in a data analysis pipeline. The multiple synthetic sets yield valid inferences about the true underlying data generating mechanism, thereby capturing the nature of the original data. This makes the multiple synthetisation procedure with `mice` suitable for further dissemination of synthetic data sets.

To non-statisticians, the procedure of generating multiple synthetic sets may seem overly complicated. We would like to emphasize that analyzing a single synthesized set, while perhaps unbiased, would underestimate the variance properties that are so important in drawing statistical inferences from finite data sets. After all, we are often not interested in the sample at hand, but in the underlying data generating mechanism, such as the population. Properly capturing the uncertainty of synthetic data sets, just like with incomplete data sets, is therefore paramount. 

Iets over meerdere data sets en disclosure risk. een cel can in theorie eigenschappen krijgen toegewezen die niet wenselijk zijn. dat is één van de mogelijkheden van what could have been. 

That said, while the field of data synthetisation originated decades ago, it is more relevant today than ever. In our study we outline a standard research workflow where the goal is to synthesize a complete data set. To simplify the simulation we adopted a bootstrapping scheme to induce sampling variance in order to conform to the combination procedure defined by @reiter_partially_inference_2003. Ideally, one would like to omit the bootstrap from the synthetization to adopt a scheme where the sampled data itself serves as a reference: much like the procedure outlined in @vink2014pooling for incomplete data simulation. The corresponding pooling rules have not been derived yet and the incorporation in data analysis workflows would require proper attention from developers alike. 

There are other developments that can generate synthetic data sets. For example, the `synthpop` [REF] package in `R` would yield valid synthetic data sets if and only if the *true* data is completely observed. When the data is not completely observed, the single-iteration monotone set-up of the algorithm will bias estimates [REF IBRAHIM]. To avoid this, one could adopt a two-step approach wherein the incomplete values are multiply imputed before synthetization. Given $m$ multiple imputations and synthetizations, at least $m^2$ synthetic data sets are then in order. The flexibility with `mice` is that both unobserved and observed data values can be synthesized at once, without the need for a two-step approach. With `mice` $m$ synthetic sets are sufficient.

itereren. als missingness en synth, dan moet je itereren. 

The ease of use when synthesizing data with `mice` in `R`, together with the validity of inferences obtained through this procedure opens up a wealth of possibilities for data dissemination and further research of initially private data. 




```{r}
library(mice)
library(dplyr)
library(magrittr)
meth <- make.method(boys)
meth["bmi"] <- "~ I(wgt / (hgt / 100)^2)"
pred <- make.predictorMatrix(boys)
pred[c("hgt", "wgt"), "bmi"] <- 0
imp <-mice(boys, 
           meth = meth, 
           pred = pred, 
           print = FALSE)
with(imp, lm(wgt ~ age + bmi))%>% pool() %>% summary()
with(imp, lm(bmi ~ I((wgt / (hgt/100)^2))))%>% pool() %>% summary()
library(MASS)
with(imp, polr(gen ~ age + bmi, Hess = TRUE)) %>% pool() %>% summary()
```

# log reg prediction of rows



# Synthesizing data with `mice`

**!!PROBABLY NOT USED!!**

*To display the applicability of `mice` for generating synthetic data, we will display three distinct simulation set-ups that build up in complexity. The first case considers a multivariable regression model, in which the normally distributed outcome variable $y$ is regressed on three normally distributed predictor variables $\{x_1, x_2, x_3\}$, which are bivariately correlated with $\rho_{x_i, x_j} = 0.3$. The regression coefficients are specified in such a way that $\beta_2$ equals $2\beta_1$ and $\beta_3$ equals $3\beta_1$. Additionally, the proportion explained variance in $y$ equals $R^2=0.25$. Hence, the population regression weights equal $\beta_1 = 0.11$, $\beta_2 = 0.22$ and $\beta_3 = 0.33$.*

*The second simulation involves a logistic regression model, in which $y$ follows a Bernoulli distribution with probability*
$$
\frac{1}{1 + \text{exp}\{-X\beta\}},
$$
*with predictor matrix $X$, consisting of 4 predictors. Here, $x_3$ moderates the relationship between $x_2$ and $y$, while $x_4$ is transformed into a categorical variable with three levels.*




<!--

Now, we aim to generate the replacement values for the actually observed data $Y_{syn}$, instead of values that replace missing values $Y_{imp}$. 

Using FCS, for every variable containing missing values, a model is constructed to impute the missing values on a given variable conditional on all other variables in the data, and the posterior distribution of the parameters used in the model at hand, on a variable by variable basis, which yields $P(Y_{mis} | X, \theta)$. 


The `mice` package has been developed originally for multiple imputation of missing data, but can be easily extended to the synthetic data framework. It proceeds by drawing missing or synthetic values from the joint distribution of the observed data. This joint density is generally hard or impossible to derive, which can be overcome by employing fully conditional specification (FCS). Consider a $n \times k$ data matrix $Y$, with values to be replaced $Y^{old}$, the values to be kept $Y^{keep}$ and the values that are already replaced $Y^{new}$, under the assumption that there are no missing values in the observed data set. Instead of drawing from the joint distribution, we draw from $k$ univariate conditional densities for each variable. That is, we draw from the distribution $P\big{(}Y_j^{old} | Y^{keep}, Y^{new}, Y^{old}_{-j}, \theta \big{)}$, where the drawn values are conditional upon the values that are to be kept, the synthetic values that are drawn at an earlier iteration and the values that still are to be replaced, with $j = 1, 2, \dots, k$ and $\theta$ indicating the parameter specifying the distribution of $Y_j^{old}$. Thus, the synthetic values are generated variable by variable. This procedure is executed $i = 1, 2, \dots, m$ times, resulting in $\textbf{D} = \{D^{(1)}, \dots, D^{(m)}\}$ synthetic data sets, with $D^{(i)} = (Y^{keep}, Y^{i, new})$.

To select the values that are to be replaced, one can utilize the `where` parameter in the `mice` function. This parameter allows one to set which values of the data are to be imputed. 

-->






KEY: Het moet niet mogelijk zijn om de echte waarden te reverse engineeren. De stochastische component van multiple imputation zorgt er voor dat dit onmogelijk is. Wat wel kan worden afgeleid is het ware data genererende model - en dat is nou precies de bedoeling. 



<!--

It is easy to draw



The goal then is to release multiply imputed data sets that bear no risk of releasing confidential or identifying information, while the multivariate relationships should be preserved as in the observed data.




The fact that the then released data is synthetic could potentially fulfil the needs for openly accessible data, without running into barriers with regard to privacy and confidentiality constraints.


, based on the multiple imputation framework [@rubin_multiple_1987]. 


Potentially, these approaches  However, there is no such thing as a free lunch: data collectors have to put effort in creating synthetic data, and using incorrect models to generate synthetic data might yield biased results for potential analysts of the data. It thus is crucial that the synthesizing process will be as easy as it gets, so that the step to release synthetic data is as small as possible.


An alternative has been offered by @rubin_statistical_disclosure_1993, who, building on the framework of multiple imputation, proposed to release multiple synthetic data sets to the public. Conform this approach, all units that are in the population but not in the sample are treated as missing data. These values are imputed by means of conventional multiple imputation approaches, and simple random samples are drawn from the population. Ultimately, these samples are released to the public. In practice, it is not required to impute the complete population, since random samples can be drawn from the sampling frame, so that only these sampled values have to be imputed. The data sets generated under this approach are labelled as *fully synthetic data sets*. However, note that, if one draws simple random samples from the sampling frame, the possibility exists that actual observations are included. 

A second procedure to creating synthetic data sets has been proposed by @little_statistical_1993, named *partially synthetic data sets*, which originated as a procedure that required synthesizing only those values that are at a high risk of being disclosive. These values can be complete variables that could be compared with publicly available data sets or registers, such as addresses, or it can be certain values that bear a high risk of being disclosive, say, income values above a certain threshold. Similarly to the fully synthetic data approach, multiple data sets containing synthetic values are released to the public, although in this instance, only the values at a high risk vary over the synthetic data sets. However, nothing keeps us from treating all values in the data set as bearing a high disclosure risk, resulting in data sets that are completely existing of synthetic values. This approach basically implements the idea of fully synthetic data, based on the partially synthetic data procedure.

-- -- HIER MIST NOG EEN OVERGANG WAAR IK NOG NIET UIT BEN -- -- 


As of today, most papers in this field address methodological issues concerning both fully and partially synthetic data sets, both with regard to analysis methods suitable for creating synthetic data, and concerning inferential procedures. The current paper aims at reducing the gap between the theory about synthetic data, and generating synthetic data in practice. Due to the conceptual similarities between imputation for missing data and imputation for synthetic data, we propose that the R-package `mice` is capable of bridging the gap between theory and actual applications. Originally, `mice` is developed as an R-package to impute values subject to non-response. However, algorithmically, the procedure of imputing values subject to non-response does not need to differ from imputing synthetic data. Both approaches can be based on fully conditional specification (FCS) as implemented in `mice`. Conform this approach, values are drawn iteratively from the posterior predictive distribution of the variable of interest conditional on all other variables, for each variable separately. Thus, previously imputed values are taken into account in the imputation model for variables that are imputed later on. 

Since `mice` is currently only capable of imputing the data at hand, the approach should be labelled as *partially synthetic*. That is, although it is completely possible to create a synthetic data set that consists of only synthetic values, `mice` is not (yet) capable of imputing observations that are not present in the data. Creating fully synthetic data sets by means of `mice` remains an area of future research.


-- -- NOT SURE YET: CONTRAST FULLY AND PARTIALLY SYNTHETIC DATA -- --



**Intro**

- Motivation/relevance

- Synthetic data (fully/partially shortly explained)

- How can this data be generated in practice (FCS - multivariate synthetic values)

- Mice adopts FCS for missing data

- It will be shown that mice is also capable of generating multivariate synthetic data

- However, multiple rules for correct variance estimates have been proposed, but the choice of one optimal variance estimate is not straightforward. Therefore, the performance of the currently available variance estimators (as outlined below) will be contrasted

- Goal: explain and show how mice can be used to create synthetic versions of the data at hand, and which variance estimator yields the best results.

**Synthetic data explained**

*Fully synthetic data*

- Explain the idea in more depth than in the intro
- Explain pooling rules by Raghunathan, Reiter & Rubin
- Adjusted variance estimate by Reiter (restricted positive)
- Simple variance estimator by `synthpop` authors.

*Partially synthetic data*

- Explain the idea in more depth than in the intro
- Explain pooling rules by Reiter.
- Adjusted estimate by `synthpop` authors.

**Mice**

 - Explain algorithm (FCS) in more depth
 - What is synthetic data
 - Why is it useful
 - Why should it be easy to generate
 - Parrallel to missing data
 - If similar to missing data then why not use mice
 - All fun and game, but statistical properties should be intact
 - In this paper we demonstrate a straigthforward workflow for generating synthetic data sets and we investigate how to obtain valid inferences from synthesized data. 
 
## Generating synthetic data with mice
- Explain FCS in short
- Demonstrate procedure with where matrix and explain rationale
- Demonstrate that it is a reasonable approach based figure that shows obs relations and synth relations side-by-side (e.g. wgt ~ age | gen)
- Observed values can be regarded as starting values for the imputation model. Since the observed data is used for creating the imputation models, no iterations are required. That is, the model is fixed, and not dependent on the imputed values.

## Drawing inferences from mice synthesized data
- What ways are there (with minimal - if any - escapes to partial/fully synthesized)
- If based on your earlier work, cite the online reference for your simulations and give URL. No need to go into detail about it here. 

### Simulation
- Simulation set-up
- Evaluation criteria explained: the bias cov ciw triangle
- Table with demonstrate bias cov ciw for all methods

## Discussion
- Summarize findings
- Stress that only holds for sampled data. Explain that for fully observed populations, one would need no sampling variance. 
- Revisit the simplicity and the readily available solution within the mice workflow (if adjusted pool is required, add to mice and direct to that function)


# FULLY/PARTIALLY synthetic data

## Fully synthetic data

DISCUSS APPROACH IN MORE DEPTH

Explain pooling rules (variance estimates + adjusted variance estimates + simple estimator proposed by synthpop authors)

## Partially synthetic data

DISCUSS APPROACH IN MORE DEPTH

Explain pooling rules (variance estimates)

# Mice

- Discuss the FCS algorithm in more detail.
- Discuss mice, predominantly the imputation algorithm in greater depth
- Procedure: observed values can be regarded as starting values, so that all variables can be used for the synthesis of all other variables.

# Simulations

## Methods

- Boys data - bootstrapped to obtain a population.
- explain simple synthetic data procedure
- explain imputation settings
- CART has been proposed by Reiter


## Results





## References

