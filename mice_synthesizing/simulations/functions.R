## pool.lm.syn

## If you have a multiply imputed synthetic dataset, that is, multiple fully imputed 
## datasets that are generated by mice, using an all-ones matrix as the where matrix, 
## this function can be used to analyse the synthetic data by means of a linear 
## regression model, and to pool the results.

# FULLY SYNTHETIC POOL FUNCTION
pool.syn <- function(mira) {
  
  if(class(mira)[1] == "mira") { # if the input object is of class mira
    fitlist <- mira %$% analyses # extract the analyses from the mira object
  }
  else {                         # and otherwise, just take the input list
    fitlist <- mira
  }
  
  vars <- fitlist[[1]] %>% coef() %>% names()
  
  m <- length(fitlist)           # number of imputations
  
  pooled <- fitlist %>% 
    map_dfr(broom::tidy) %>%     # tidy estimates
    group_by(term) %>%           # group per variable
    summarise(est     = mean(estimate),
              bm      = sum((estimate - est)^2) / (m - 1),
              ubar    = mean(std.error^2),
              var_u   = (1 + 1/m) * bm - ubar,
              var     = if_else(var_u > 0, var_u, ubar), # restrict variance to be positive
              df      = max(1, (m - 1) * (1 - ubar / (bm + bm/m))^2), # restrict df > 1
              lower   = est - qt(.975, df) * sqrt(var),
              upper   = est + qt(.975, df) * sqrt(var), .groups = 'drop') %>%
    arrange(factor(term, levels = vars))
  pooled
}

# FULLY SYNTHETIC POOL FUNCTION WITH ADJUSTED (M-1) DF
pool2.syn <- function(mira) {
  
  if(class(mira)[1] == "mira") { # if the input object is of class mira
    fitlist <- mira %$% analyses # extract the analyses from the mira object
  }
  else {
    fitlist <- mira              # and otherwise, just take the input list
  }
  
  vars <- fitlist[[1]] %>% coef() %>% names()
  
  m <- length(fitlist)           # number of imputations
  
  pooled <- fitlist %>% 
    map_dfr(broom::tidy) %>%     # tidy estimates
    group_by(term) %>%           # group per variable
    summarise(est     = mean(estimate),
              bm      = sum((estimate - est)^2) / (m - 1),
              ubar    = mean(std.error^2),
              var_u   = (1 + 1/m) * bm - ubar,
              var     = if_else(var_u > 0, var_u, ubar), # restrict variance > 0
              df      = max(m - 1, (m - 1) * (1 - ubar / (bm + bm/m))^2), # restrict df > m-1
              lower   = est - qt(.975, df) * sqrt(var),
              upper   = est + qt(.975, df) * sqrt(var), .groups = 'drop') %>%
    arrange(factor(term, levels = vars))
  
  pooled
}

# PARTIALLY SYNTHETIC DATA POOL FUNCTION
pool3.syn <- function(mira) {
  
  if(class(mira)[1] == "mira") { # if the input object is of class mira
    fitlist <- mira %$% analyses # extract the analyses from the mira object
  }
  else {
    fitlist <- mira              # and otherwise, just take the input list
  }
  
  vars <- fitlist[[1]] %>% coef() %>% names()
  
  m <- length(fitlist)           # number of imputations
  
  pooled <- fitlist %>% 
    map_dfr(broom::tidy) %>%
    group_by(term) %>%
    summarise(est     = mean(estimate),
              bm      = sum((estimate - est)^2) / (m - 1),
              ubar    = mean(std.error^2),
              var     = ubar + bm/m, # new variance estimate
              df      = (m - 1) * (1 + (ubar * m)/bm)^2, # and new df estimate
              lower   = est - qt(.975, df) * sqrt(var),
              upper   = est + qt(.975, df) * sqrt(var), .groups = 'drop') %>%
    arrange(factor(term, levels = vars))
  pooled
}


ci_cov <- function(pooled, true_fit = NULL, coefs = NULL, vars = NULL) {
  
  if (!is.null(true_fit)) {
    coefs <- coef(true_fit)
    vars   <- diag(vcov(true_fit))
  }
  
  nsim <- nrow(pooled) / length(unique(pooled$term))
  
  pooled %>% mutate(true_coef = rep(coefs, times = nsim),
                    true_var  = rep(vars, times = nsim),
                    cover     = lower < true_coef & true_coef < upper) %>%
    group_by(term) %>%
    summarise("True Est" = unique(true_coef),
              "Syn Est"  = mean(est),
              "Bias"     = mean(est - true_coef),
              "True SE"  = unique(sqrt(true_var)),
              "Syn SE"   = mean(sqrt(var)),
              "df"       = mean(df),
              "Lower"    = mean(lower),
              "Upper"    = mean(upper),
              "CIW"      = mean(upper - lower),
              "Coverage" = mean(cover), .groups = "drop")
}

make.coefficients <- function(r2, ratio, rho, model = c("normal", "logit", "probit")) {
  if (model == "normal") {
    var_y <- r2
  }
  else if (model == "logit") {
    var_y <- (r2 * pi^2 / 3) / (1 - r2)
  }
  sqrt(var_y / sum(ratio %*% t(ratio) * rho)) * ratio
}

generate.data <- function(r2, betas, rho, n, model = c("normal", "logit", "probit")) {
  
  X <- mvrnormArma(n, mu = rep(0, length(betas)), sigma = rho)
  
  if (model == "normal") {
    Y <- X %*% betas + rnorm(n = n, mean = 0, sd = sqrt(1 - r2))
  }
  if (model == "logit") {
    Y <- rbinom(n, 1, 1 / (1 + exp(-(X %*% betas))))
  }
  bind_cols(X = as.data.frame(X), Y = Y)
}
